{
  "id": "23d5718c6a84",
  "title": "Day 1066",
  "createdAt": "2025-02-21 04:53:14",
  "tags": [
    "coding"
  ],
  "url": "https://chepenikconor.medium.com/day-1066-23d5718c6a84",
  "content": "# Day 1066\n\nYou can just have AI code you things. Like a fun game you wanted to make up and play:\n\n```javascript\nconst canvas = document.getElementById('gameCanvas');\nconst ctx = canvas.getContext('2d');\n\n// Constants\nconst WIDTH = 800;\nconst HEIGHT = 600;\nconst TWO_PLAYER_WIDTH = 1200;  // Wider screen for two players\n\n// Colors\nconst COLORS = {\n    PLAYER_1: '#4B0082',  // Deep Purple\n    PLAYER_2: '#006400',  // Dark Green\n    SHIELD: '#00FFFF',    // Cyan\n    BAD_BLOCKS: [\n        '#FF00FF',  // Neon magenta\n        '#FF1493',  // Deep pink\n        '#00FF00',  // Lime\n        '#FF4500',  // Orange-red\n        '#8B0000',  // Dark red\n        '#9400D3',  // Dark violet\n        '#FF8C00',  // Dark orange\n        '#B22222'   // Fire brick\n    ],\n    BOOST_STAR: '#FFD700', // Gold\n    BACKGROUND: '#000000',\n    TEXT: '#FFFFFF'\n};\n\nconst LEVELS = [\n    { name: \"Level 1\", blockSpeed: 1, spawnRate: 0.01, maxBlocks: 3 },\n    { name: \"Level 2\", blockSpeed: 1.5, spawnRate: 0.015, maxBlocks: 4 },\n    { name: \"Level 3\", blockSpeed: 2, spawnRate: 0.02, maxBlocks: 5 },\n    { name: \"Level 4\", blockSpeed: 2.5, spawnRate: 0.025, maxBlocks: 6 },\n    { name: \"Level 5\", blockSpeed: 3, spawnRate: 0.03, maxBlocks: 7 }\n];\n\nclass StarBoost {\n    constructor() {\n        this.size = 25;\n        this.points = 5;\n        this.rotation = 0;\n        this.x = Math.random() * (canvas.width - 2 * this.size) + this.size;\n        this.y = -this.size;\n        this.speedY = 2;\n        this.color = COLORS.BOOST_STAR;\n    }\n\n    move() {\n        this.y += this.speedY;\n        this.rotation += 0.02;\n        return this.y > canvas.height + this.size;\n    }\n\n    draw() {\n        ctx.save();\n        ctx.translate(this.x, this.y);\n        ctx.rotate(this.rotation);\n\n        ctx.beginPath();\n        for (let i = 0; i < this.points * 2; i++) {\n            const radius = i % 2 === 0 ? this.size : this.size/2;\n            const angle = (i * Math.PI) / this.points;\n            const x = Math.cos(angle) * radius;\n            const y = Math.sin(angle) * radius;\n            if (i === 0) {\n                ctx.moveTo(x, y);\n            } else {\n                ctx.lineTo(x, y);\n            }\n        }\n        ctx.closePath();\n\n        ctx.fillStyle = this.color;\n        ctx.fill();\n        ctx.strokeStyle = '#FFFFFF';\n        ctx.stroke();\n\n        // Add \"BOOST\" text in white\n        ctx.rotate(-this.rotation);\n        ctx.fillStyle = COLORS.TEXT;\n        ctx.font = '12px Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText('BOOST', 0, 5);\n\n        ctx.restore();\n    }\n}\n\nclass Player {\n    constructor(isPlayer2 = false) {\n        this.width = 50;\n        this.height = 50;\n        this.x = canvas.width / (isPlayer2 ? 3 : 1.5) - this.width / 2;\n        this.y = canvas.height - this.height - 20;\n        this.baseSpeed = 7;\n        this.color = isPlayer2 ? COLORS.PLAYER_2 : COLORS.PLAYER_1;\n        this.hearts = 3;\n        this.maxBoostTime = 300;\n        this.boostMeter = this.maxBoostTime;\n        this.boostRechargeCounter = 0;\n        this.isPlayer2 = isPlayer2;\n        this.score = 0;\n    }\n\n    draw() {\n        ctx.fillStyle = this.color;\n        ctx.beginPath();\n        ctx.moveTo(this.x + this.width/2, this.y);\n        ctx.lineTo(this.x, this.y + this.height);\n        ctx.lineTo(this.x + this.width, this.y + this.height);\n        ctx.closePath();\n        ctx.fill();\n\n        if (this.hearts > 0) {\n            ctx.strokeStyle = COLORS.SHIELD;\n            ctx.beginPath();\n            ctx.arc(this.x + this.width/2, this.y + this.height/2, 40, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n    }\n\n    move(keys) {\n        const isSinglePlayer = this.game && this.game.mode === 'single';\n        const controls = this.isPlayer2 ? {\n            up: 'ArrowUp',\n            down: 'ArrowDown',\n            left: 'ArrowLeft',\n            right: 'ArrowRight',\n            boost: 'ShiftRight'\n        } : {\n            up: 'KeyW',\n            down: 'KeyS',\n            left: 'KeyA',\n            right: 'KeyD',\n            boost: 'Space'\n        };\n\n        // In single player mode, allow both control schemes\n        const boostActive = isSinglePlayer ? \n            (keys[controls.boost] || keys['ShiftRight']) :\n            keys[controls.boost];\n\n        const speed = boostActive ? this.baseSpeed * 2 : this.baseSpeed;\n\n        // Movement logic for single player (both control schemes) or specific player in two-player mode\n        if (isSinglePlayer) {\n            // Allow both WASD and arrow keys in single player\n            if ((keys['KeyA'] || keys['ArrowLeft']) && this.x > 0) this.x -= speed;\n            if ((keys['KeyD'] || keys['ArrowRight']) && this.x < canvas.width - this.width) this.x += speed;\n            if ((keys['KeyW'] || keys['ArrowUp']) && this.y > 0) this.y -= speed;\n            if ((keys['KeyS'] || keys['ArrowDown']) && this.y < canvas.height - this.height) this.y += speed;\n        } else {\n            // Original two-player controls\n            if (keys[controls.left] && this.x > 0) this.x -= speed;\n            if (keys[controls.right] && this.x < canvas.width - this.width) this.x += speed;\n            if (keys[controls.up] && this.y > 0) this.y -= speed;\n            if (keys[controls.down] && this.y < canvas.height - this.height) this.y += speed;\n        }\n\n        if (boostActive) {\n            this.boostMeter = Math.max(0, this.boostMeter - 1);\n            this.boostRechargeCounter = 0;\n        } else {\n            this.boostRechargeCounter++;\n            if (this.boostRechargeCounter >= 10) {\n                this.boostMeter = Math.min(this.maxBoostTime, this.boostMeter + 1);\n                this.boostRechargeCounter = 0;\n            }\n        }\n    }\n}\n\nclass Block {\n    constructor() {\n        this.size = 20;\n        const side = ['top', 'bottom', 'left', 'right'][Math.floor(Math.random() * 4)];\n\n        switch(side) {\n            case 'top':\n                this.x = Math.random() * canvas.width;\n                this.y = -this.size;\n                this.speedX = 0;\n                this.speedY = Math.random() * 2 + 1;\n                break;\n            case 'bottom':\n                this.x = Math.random() * canvas.width;\n                this.y = canvas.height + this.size;\n                this.speedX = 0;\n                this.speedY = -(Math.random() * 2 + 1);\n                break;\n            case 'left':\n                this.x = -this.size;\n                this.y = Math.random() * canvas.height;\n                this.speedX = Math.random() * 2 + 1;\n                this.speedY = 0;\n                break;\n            case 'right':\n                this.x = canvas.width + this.size;\n                this.y = Math.random() * canvas.height;\n                this.speedX = -(Math.random() * 2 + 1);\n                this.speedY = 0;\n                break;\n        }\n\n        this.color = Math.random() < 0.3 ? COLORS.SHIELD : \n                     COLORS.BAD_BLOCKS[Math.floor(Math.random() * COLORS.BAD_BLOCKS.length)];\n        this.type = this.color === COLORS.SHIELD ? 'good' : 'bad';\n        this.isCircle = this.type === 'good';\n    }\n\n    move(gameTime) {\n        const speedFactor = Math.min(1 + (gameTime / 3600), 5);\n        this.x += this.speedX * speedFactor;\n        this.y += this.speedY * speedFactor;\n        \n        return this.x < -this.size || this.x > canvas.width + this.size || \n               this.y < -this.size || this.y > canvas.height + this.size;\n    }\n\n    draw() {\n        ctx.fillStyle = this.color;\n        ctx.strokeStyle = '#FFFFFF';\n        \n        if (this.isCircle) {\n            ctx.beginPath();\n            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);\n            ctx.fill();\n            ctx.stroke();\n        } else {\n            ctx.fillRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);\n            ctx.strokeRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);\n        }\n    }\n}\n\nclass Game {\n    constructor() {\n        this.state = 'menu'; // menu, playing, game_over\n        this.mode = null; // null, 'single', 'two_player'\n        this.players = [];\n        this.blocks = [];\n        this.stars = [];\n        this.gameTime = 0;\n        this.keys = {};\n        this.currentLevel = 0;\n        this.levelScore = 0;\n\n        window.addEventListener('keydown', (e) => {\n            if(['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'KeyW', 'KeyS', 'KeyA', 'KeyD', 'ShiftRight'].includes(e.code)) {\n                e.preventDefault();\n            }\n            this.keys[e.code] = true;\n\n            if (this.state === 'menu') {\n                if (e.code === 'Digit1') {\n                    this.startGame('single');\n                } else if (e.code === 'Digit2') {\n                    this.startGame('two_player');\n                }\n            } else if (this.state === 'game_over' && e.code === 'KeyR') {\n                this.restart();\n            }\n        });\n        window.addEventListener('keyup', (e) => this.keys[e.code] = false);\n    }\n\n    startGame(mode) {\n        this.mode = mode;\n        canvas.width = mode === 'two_player' ? TWO_PLAYER_WIDTH : WIDTH;\n        this.players = [new Player()];\n        if (mode === 'two_player') {\n            this.players.push(new Player(true));\n        }\n        this.blocks = [];\n        this.stars = [];\n        this.gameTime = 0;\n        this.state = 'playing';\n    }\n\n    update() {\n        if (this.state !== 'playing') return;\n\n        this.gameTime++;\n        this.players.forEach(player => {\n            player.game = this; // Add reference to game instance\n            player.move(this.keys);\n        });\n\n        // Level progression\n        const level = LEVELS[this.currentLevel];\n        const totalScore = this.players.reduce((sum, player) => sum + player.score, 0);\n        if (this.levelScore + 50 <= totalScore && this.currentLevel < LEVELS.length - 1) {\n            this.currentLevel++;\n            this.levelScore = totalScore;\n            // Display level up message\n            this.levelUpTime = this.gameTime;\n        }\n\n        // Spawn blocks and stars based on current level\n        if (Math.random() < level.spawnRate && this.blocks.length < level.maxBlocks) {\n            const block = new Block();\n            block.speedX *= level.blockSpeed;\n            block.speedY *= level.blockSpeed;\n            this.blocks.push(block);\n        }\n        if (Math.random() < 0.002) {\n            this.stars.push(new StarBoost());\n        }\n\n        // Update stars\n        for (let i = this.stars.length - 1; i >= 0; i--) {\n            const star = this.stars[i];\n            if (star.move()) {\n                this.stars.splice(i, 1);\n                continue;\n            }\n\n            for (const player of this.players) {\n                if (this.checkCollision(player, star)) {\n                    player.boostMeter = player.maxBoostTime;\n                    player.score += 5;\n                    this.stars.splice(i, 1);\n                    break;\n                }\n            }\n        }\n\n        // Update blocks and check for game over conditions\n        for (let i = this.blocks.length - 1; i >= 0; i--) {\n            const block = this.blocks[i];\n            if (block.move(this.gameTime)) {\n                this.blocks.splice(i, 1);\n                continue;\n            }\n\n            for (const player of this.players) {\n                if (this.checkCollision(player, block)) {\n                    if (block.type === 'good') {\n                        player.hearts = Math.min(3, player.hearts + 1);\n                        player.score += 10;\n                    } else {\n                        player.hearts--;\n                        if (player.hearts <= 0) {\n                            if (this.mode === 'single') {\n                                this.state = 'game_over';\n                                this.saveScore();\n                            } else if (this.mode === 'two_player') {\n                                // In two-player mode, check if we should end the game\n                                const otherPlayer = this.players.find(p => p !== player);\n                                if (otherPlayer.hearts <= 0) {\n                                    // Both players dead - it's a draw\n                                    this.state = 'game_over';\n                                    this.winner = 'draw';\n                                } else {\n                                    // One player dead, other alive - declare winner\n                                    this.state = 'game_over';\n                                    this.winner = otherPlayer.isPlayer2 ? 'player2' : 'player1';\n                                }\n                                this.saveScore();\n                            }\n                        }\n                    }\n                    this.blocks.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n\n    drawMenu() {\n        ctx.fillStyle = COLORS.BACKGROUND;\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n        ctx.fillStyle = COLORS.TEXT;\n        ctx.font = '48px Arial';\n        ctx.textAlign = 'center';\n        ctx.fillText('Space Shield', canvas.width/2, canvas.height/2 - 50);\n\n        ctx.font = '24px Arial';\n        ctx.fillText('Press 1 for Single Player', canvas.width/2, canvas.height/2 + 20);\n        ctx.fillText('Press 2 for Two Players', canvas.width/2, canvas.height/2 + 60);\n\n        ctx.font = '18px Arial';\n        ctx.fillText('Player 1: WASD to move, SPACE for boost', canvas.width/2, canvas.height/2 + 120);\n        ctx.fillText('Player 2: Arrow Keys to move, Right SHIFT for boost', canvas.width/2, canvas.height/2 + 150);\n    }\n\n    draw() {\n        if (this.state === 'menu') {\n            this.drawMenu();\n            return;\n        }\n\n        ctx.fillStyle = COLORS.BACKGROUND;\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n        this.players.forEach(player => player.draw());\n        this.blocks.forEach(block => block.draw());\n        this.stars.forEach(star => star.draw());\n\n        // Draw HUD\n        ctx.fillStyle = COLORS.TEXT;\n        ctx.font = '20px Arial';\n        ctx.textAlign = 'left';\n\n        // Player 1 HUD\n        this.drawPlayerHUD(this.players[0], 10);\n\n        // Player 2 HUD (if exists)\n        if (this.mode === 'two_player' && this.players[1]) {\n            this.drawPlayerHUD(this.players[1], canvas.width - 200);\n        }\n\n        if (this.state === 'game_over') {\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = COLORS.TEXT;\n            ctx.font = '48px Arial';\n            ctx.textAlign = 'center';\n\n            if (this.mode === 'two_player') {\n                let winnerText = 'Game Over! ';\n                if (this.winner === 'draw') {\n                    winnerText += \"It's a Draw!\";\n                } else {\n                    winnerText += `${this.winner === 'player1' ? 'Player 1' : 'Player 2'} Wins!`;\n                }\n                ctx.fillText(winnerText, canvas.width/2, canvas.height/2);\n            } else {\n                ctx.fillText('Game Over!', canvas.width/2, canvas.height/2);\n            }\n\n            // Display scores\n            ctx.font = '24px Arial';\n            this.players.forEach((player, index) => {\n                const yOffset = index * 40;\n                ctx.fillText(`Player ${index + 1} Score: ${player.score}`, \n                           canvas.width/2, canvas.height/2 + 40 + yOffset);\n            });\n            ctx.fillText('Press R to Restart', canvas.width/2, canvas.height/2 + 120);\n        }\n    }\n\n    drawPlayerHUD(player, x) {\n        ctx.fillText(`Player ${player.isPlayer2 ? '2' : '1'}`, x, 30);\n        ctx.fillText(`Hearts: ${player.hearts}`, x, 60);\n        ctx.fillText(`Score: ${player.score}`, x, 90);\n        ctx.fillText(`Boost: ${Math.floor(player.boostMeter/60)}s`, x, 120);\n        ctx.fillText(`${LEVELS[this.currentLevel].name}`, x, 150);\n\n        // Show level up message\n        if (this.levelUpTime && this.gameTime - this.levelUpTime < 180) {\n            ctx.save();\n            ctx.fillStyle = '#FFD700';\n            ctx.font = '32px Arial';\n            ctx.textAlign = 'center';\n            ctx.fillText(`Level Up! ${LEVELS[this.currentLevel].name}`, canvas.width/2, canvas.height/2 - 100);\n            ctx.restore();\n        }\n    }\n\n    checkCollision(player, object) {\n        const playerRect = {\n            x: player.x,\n            y: player.y,\n            width: player.width,\n            height: player.height\n        };\n\n        if (object instanceof StarBoost || object.isCircle) {\n            const circleDistX = Math.abs(object.x - (playerRect.x + playerRect.width/2));\n            const circleDistY = Math.abs(object.y - (playerRect.y + playerRect.height/2));\n\n            if (circleDistX > (playerRect.width/2 + object.size)) return false;\n            if (circleDistY > (playerRect.height/2 + object.size)) return false;\n\n            if (circleDistX <= playerRect.width/2) return true;\n            if (circleDistY <= playerRect.height/2) return true;\n\n            const cornerDistSq = Math.pow(circleDistX - playerRect.width/2, 2) +\n                               Math.pow(circleDistY - playerRect.height/2, 2);\n\n            return cornerDistSq <= Math.pow(object.size, 2);\n        } else {\n            const blockRect = {\n                x: object.x - object.size,\n                y: object.y - object.size,\n                width: object.size * 2,\n                height: object.size * 2\n            };\n\n            return !(playerRect.x + playerRect.width < blockRect.x || \n                    blockRect.x + blockRect.width < playerRect.x || \n                    playerRect.y + playerRect.height < blockRect.y || \n                    blockRect.y + blockRect.height < playerRect.y);\n        }\n    }\n\n    async saveScore() {\n        if (!this.state === 'game_over') return;\n\n        try {\n            // Save highest score between players\n            const highestScore = Math.max(...this.players.map(p => p.score));\n            const response = await fetch('/save_score', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({ score: highestScore })\n            });\n\n            if (response.status === 401) {\n                const loginPrompt = document.createElement('div');\n                loginPrompt.className = 'alert alert-info mt-3';\n                loginPrompt.innerHTML = 'Login to save your score! <a href=\"/login\" class=\"alert-link\">Login here</a>';\n                document.querySelector('.game-container').appendChild(loginPrompt);\n            } else if (!response.ok) {\n                console.error('Failed to save score');\n                const data = await response.json();\n                console.error(data.error);\n            } else {\n                console.log('Score saved successfully!');\n            }\n        } catch (error) {\n            console.error('Error saving score:', error);\n        }\n    }\n\n    restart() {\n        this.state = 'menu';\n        canvas.width = WIDTH;\n    }\n}\n\nconst game = new Game();\n\nfunction gameLoop() {\n    game.update();\n    game.draw();\n    requestAnimationFrame(gameLoop);\n}\n\ngameLoop();\n```\n\nCheck it out here - [https://space-shield.replit.app/](https://space-shield.replit.app/)\n\n2/20/25\n\nConor Jay Chepenik",
  "wordCount": 1891,
  "readingTime": 7.1358490566037736,
  "claps": 0,
  "voters": 0
}